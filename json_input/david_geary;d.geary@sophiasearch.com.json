{"contentItems": [{"content": "All modules that allow groovy (filter, script, transform, router, tcpclient) allow automatic refresh of the script when it changes. In the XD documentation it is stated that this refresh occurs every minute eg for filter at \"The script is checked for updates every 60 seconds, so it may be replaced in a running system. \" This set up can be seen in the spring xml for the modules - eg (again for filter) However from the spring integration documentation it specifies that the parameter is actually in milliseconds - ie the above XD configuration would recheck the script every 60 milliseconds which may be a performance concern as it will be checking the lastmodified time of the script file. Ideally this parameter would be configurable - in our case we would usually eliminate the refresh check altogether (set to -1) as our scripts will not change (or if they did a redeploy of the module would pick it up). This would allow multiple individual sink modules to be combined via the shell DSL so that each message sent to the composite sink module will be sent to each of the individual sink modules in turn. Internally this would probably use a recipient list router to send to each individual sink. Module options for each individual sink would be combined to create the overall options for the composite sink module in a similar way to existing composite modules. This would allow construction of streams with less communication with the message bus for example as an alternative to using a named topic in the message bus. Using this in conjunction with sinks built using existing composite module functionality (as a combination of processors and a sink) would allow more sophisticated combinations to be constructed and deployed as a single module (with no message bus One particular application of this would be with tap and counter functionality. If multiple fields in a message need counted this currently needs to be done as separate streams tapping the original with the overhead of the tapped message being read from the message bus multiple times potentially on different nodes, this enhancement would allow all the counters to be combined to make a more cohesive composite counter module so that the tapped message would only need to be read once.. Currently its possible to do this via but this involves an additional hop to the message bus for the pipe between the source and router. It would be better if this was supported directly with the existing named channel syntax to remove this pipe ie This would be useful as a possible solution in the scenario described in XD-3613 as an alternative to using topics on the Redis message bus which dont support having multiple instances of the same consumer.. Allow sending to multiple named channels at once. If I deploy more than one instance of a module (eg using 1 or 0) that consumes from a tap or topic then I get duplicate messages if Im using Redis as the message bus. It looks like this is the same issue as XD-3100 but the fix for that only fixed Rabbit as the message bus. This is easy to reproduce on a 2 container cluster using a Redis Message Bus: Create and deploy streams as follows: On container 1 send a message: Container 1 logs are then: and container 2: Ie the tapped message is duplicated (picked up by both tap module instances) Similarly for topics create and deploy these streams: On container 1 send a message: Container 1 logs are then: and container 2: Ie the topic message is picked up by each instance of the module in each stream. In this case I would expect each stream to pick up the message once ie I would get a single output for each stream test message 002 TOPIC CONSUMER 2 once (on either container) test message 002 TOPIC CONSUMER 1 once (on either container). I have a distributed XD Cluster with one admin and two containers using Redis as the message bus. In certain cases I want to use direct binding to remove communication with the message bus and deploy all modules to all containers with the aim of improving performance. Ive found that even when using direct binding, XD still communicates with Redis when it shouldnt need to. This could have an impact on performance. This is easily reproducible in our 2 container cluster as follows: Use the redis-cli monitor command to monitor Redis. Create and deploy a simple stream with direct binding: As expected both modules get deployed to both nodes. Testing shows messages sent to the http endpoint of one container always come out in the log for that container implying direct binding is in play as expected. However once the streams are deployed the Redis monitor starts showing a Redis queue being accessed from both XD conatiners: This shouldnt need to happen in direct binding. These messages stop once the stream is undeployed.. We have a use case where we need the HTTP source module to return a 204 status instead of the 200 status that is currently returned. There may be other status codes that it would be useful to be able to return. A simple additional option on the module would allow this to be configured.. ", "contenttype": "application/json", "created": 737603, "id": 2, "language": "en", "user_name": "david_geary", "email": "d.geary@sophiasearch.com"}]}